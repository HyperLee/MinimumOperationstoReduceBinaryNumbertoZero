# Minimum Operations to Reduce Binary Number to Zero

[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?style=flat-square&logo=dotnet)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-14-239120?style=flat-square&logo=csharp)](https://docs.microsoft.com/dotnet/csharp/)
[![License](https://img.shields.io/badge/License-MIT-yellow?style=flat-square)](LICENSE)

經典演算法面試題：使用二進位位元操作，計算將正整數變為零的最少操作次數。

## 題目描述

給定一個正整數 `n`，每次操作可以**加或減** $2^i$（其中 $i \geq 0$），求將 `n` 變為 `0` 的**最少操作次數**。

### 範例

| 輸入 | 輸出 | 說明 |
| ---- | ---- | ---- |
| `n = 7` | `2` | `7 (111)` → `+1` → `8 (1000)` → `-8` → `0` |
| `n = 15` | `2` | `15 (1111)` → `+1` → `16 (10000)` → `-16` → `0` |
| `n = 39` | `3` | `39 (100111)` → `+1` → `40 (101000)` → `-8` → `32` → `-32` → `0` |

## 解題思路

### 核心概念：二進位制位元處理

這道題的關鍵在於理解**二進位表示**與**進位機制**。

### 為什麼從二進位角度思考？

每次操作只能加減 $2^i$，這正好對應二進位制中的某一位。例如：

- $+1$ 或 $-1$ 影響最低位（第 0 位）
- $+2$ 或 $-2$ 影響第 1 位
- $+4$ 或 $-4$ 影響第 2 位

因此，**每個二進位的 `1` 都需要被消除**，問題轉化為：如何用最少的操作消除所有的 `1`？

### 解題策略

從**低位到高位**逐位處理，維護一個「進位」狀態：

```text
當前位值 = 原位值 + 進位
```

| 當前位值 | 處理方式 | 操作數 | 進位 |
| -------- | -------- | ------ | ---- |
| `0` | 不需要操作 | +0 | 0 |
| `1`（下一位是 `0`） | 減法消掉 | +1 | 0 |
| `1`（下一位是 `1`） | 加法產生進位 | +1 | 1 |
| `2` | 直接進位 | +0 | 1 |

### 為什麼連續的 `1` 要用加法？

這是本題最關鍵的優化點。

考慮 `n = 7`（二進位 `111`）：

**方法一：逐位減法** ❌

```text
111 → -1 → 110 → -2 → 100 → -4 → 000
需要 3 次操作
```

**方法二：加法進位** ✅

```text
111 → +1 → 1000 → -8 → 0000
只需要 2 次操作
```

> [!TIP]
> 當遇到連續的 `1` 時，使用加法將它們「合併」成一個更高位的 `1`，然後一次減掉，比逐個減掉更有效率。

## 演算法流程

### 流程圖

```text
開始
  ↓
初始化: operations = 0, carry = 0
  ↓
┌─────────────────────────────────────┐
│ while (n > 0 || carry > 0)          │
│   ↓                                 │
│   currentBit = (n & 1) + carry      │
│   ↓                                 │
│   判斷 currentBit 的值              │
│   ├─ 0: carry = 0                   │
│   ├─ 1 且下一位是 1:                │
│   │     operations++, carry = 1     │
│   ├─ 1 且下一位是 0:                │
│   │     operations++, carry = 0     │
│   └─ 2: carry = 1                   │
│   ↓                                 │
│   n = n >> 1 (右移一位)             │
└─────────────────────────────────────┘
  ↓
回傳 operations
```

## 詳細範例演示

### 範例 1：`n = 7` (二進位 `111`)

| 步驟 | n (二進位) | 當前位 | 進位 | 位值 | 下一位 | 動作 | 操作數 |
| ---- | --------- | ------ | ---- | ---- | ------ | ---- | ------ |
| 1 | `111` | 1 | 0 | 1 | 1 | +1 產生進位 | 1 |
| 2 | `11` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 3 | `1` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 4 | `0` | 0 | 1 | 1 | 0 | -1 消掉 | 2 |

**結果：2 次操作** ✅

實際操作過程：`7` → `+1` → `8` → `-8` → `0`

---

### 範例 2：`n = 39` (二進位 `100111`)

| 步驟 | n (二進位) | 當前位 | 進位 | 位值 | 下一位 | 動作 | 操作數 |
| ---- | --------- | ------ | ---- | ---- | ------ | ---- | ------ |
| 1 | `100111` | 1 | 0 | 1 | 1 | +1 產生進位 | 1 |
| 2 | `10011` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 3 | `1001` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 4 | `100` | 0 | 1 | 1 | 0 | -1 消掉 | 2 |
| 5 | `10` | 0 | 0 | 0 | - | 無操作 | 2 |
| 6 | `1` | 1 | 0 | 1 | 0 | -1 消掉 | 3 |

**結果：3 次操作** ✅

實際操作過程：`39` → `+1` → `40` → `-8` → `32` → `-32` → `0`

---

### 範例 3：`n = 100` (二進位 `1100100`)

| 步驟 | n (二進位) | 當前位 | 進位 | 位值 | 動作 | 操作數 |
| ---- | --------- | ------ | ---- | ---- | ---- | ------ |
| 1 | `1100100` | 0 | 0 | 0 | 無操作 | 0 |
| 2 | `110010` | 0 | 0 | 0 | 無操作 | 0 |
| 3 | `11001` | 1 | 0 | 1 | 減法消掉 | 1 |
| 4 | `1100` | 0 | 0 | 0 | 無操作 | 1 |
| 5 | `110` | 0 | 0 | 0 | 無操作 | 1 |
| 6 | `11` | 1 | 0 | 1 | +1 產生進位 | 2 |
| 7 | `1` | 1 | 1 | 2 | 直接進位 | 2 |
| 8 | `0` | 0 | 1 | 1 | 減法消掉 | 3 |

**結果：3 次操作** ✅

## 時間與空間複雜度

| 複雜度 | 值 | 說明 |
| ------ | ----- | ------ |
| 時間複雜度 | $O(\log n)$ | 遍歷二進位的每一位 |
| 空間複雜度 | $O(1)$ | 只使用常數額外空間 |

## 快速開始

### 前置需求

- [.NET 10.0 SDK](https://dotnet.microsoft.com/download) 或更高版本

### 執行程式

```bash
# 複製專案
git clone https://github.com/HyperLee/MinimumOperationstoReduceBinaryNumbertoZero.git
cd MinimumOperationstoReduceBinaryNumbertoZero

# 建構並執行
dotnet run --project MinimumOperationstoReduceBinaryNumbertoZero
```

### 執行結果

```text
=== Minimum Operations to Reduce Binary Number to Zero ===

✅ PASS: n=1    -> 操作次數=1  | 1 (1) -> 0，操作：-1
✅ PASS: n=2    -> 操作次數=1  | 2 (10) -> 0，操作：-2
✅ PASS: n=3    -> 操作次數=2  | 3 (11) -> 4 (100) -> 0，操作：+1, -4
✅ PASS: n=7    -> 操作次數=2  | 7 (111) -> 8 (1000) -> 0，操作：+1, -8
✅ PASS: n=15   -> 操作次數=2  | 15 (1111) -> 16 (10000) -> 0，操作：+1, -16
✅ PASS: n=39   -> 操作次數=3  | 39 (100111) -> 40 (101000) -> 32 -> 0
✅ PASS: n=100  -> 操作次數=3  | 100 (1100100) 需要 3 次操作

=== 測試結果：14 通過，0 失敗 ===
```

## 程式碼使用

```csharp
using MinimumOperationstoReduceBinaryNumbertoZero;

// 計算最少操作次數
int result = Solution.MinOperations(7);
Console.WriteLine(result); // 輸出: 2
```

## 相關資源

- [位元運算技巧](https://leetcode.com/problems/sum-of-two-integers/solutions/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently/)
- [二進位數學基礎](https://en.wikipedia.org/wiki/Binary_number)
